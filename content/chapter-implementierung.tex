\chapter{Implementierung}
	Aus den oben beschrieben Überlegungen und dem in \cref{fig:flowchart} gezeigten grundlegenden Programmablauf folgt die nachfolgend beschriebene Implementierung in Software.
	Zeilen 7-9 der \textit{main.cpp} importieren neben der online verfügbaren Bibliothek \texttt{mouse.h}, die die nötigen Funktionalitäten zur Steuerung der Maus des Host-Computers zur Verfügung stellt, die beiden Header-files \texttt{defines.h} und \texttt{helper\_functions.h}.
	\texttt{defines.h} beinhaltet Konstanten in Form von Compilerdefinitionen, die zur Laufzeit nicht geändert werden.
	In \texttt{helper\text\_funtions.h} bzw. \texttt{helper\text\_functions.cpp} sind die direkt mit dem Touchscreen in Zusammenhang stehenden Funktionen ausgegliedert.\par\medskip

	Zeilen 21-23 der \texttt{main.cpp} initialisieren drei globale Variablen -- für jede Achsrichtung ein Array der Länge \texttt{OVERSAMPLING} (siehe \texttt{defines.h}) und ein Pointer, die im weiteren Verlauf zur Auswertung benötigt werden.

	\section{Vorbereitung der MCU}
		Um mögliche Fehlerquellen etwa durch \textit{cross-talking} zwischen GPIOs und der ADC auszuschließen, werden wie in \cite{MicrochipTechnologyInc.ATmega32U4.Datasheet.2016} auf Seite 71 beschrieben alle ungenutzten Pins in einen definierten Zustand -- hier als \textit{Input} mit aktiviertem \textit{Pull-Up} -- versetzt.
		Als Schnittstelle zum Touchscreen kommen nur Pins an Port F zum Einsatz welche vorbereitend ebenfalls als Input, allerdings ohne Pull-Up konfiguriert werden.\par\medskip

		Die internen ADC verwenden einen eigenen Timer der durch setzen der Bits \texttt{ADPSx} im \texttt{ADCSRA}-Register konfiguriert wird.
		Diese bestimmen den Prescaler, der die CPU-Clock auf die gewünschte ADC-Frequenz herunter teilt.
		Um die volle Auflösung der ADC sicher ausnutzen zu können, darf die Frequenz des ADC-Timers gemäß Datenblatt \SI{200}{\kilo\hertz} nicht überschreiten.
		\begin{figure}[h]
			\centering
			\includegraphics[width=.9\textwidth]{fig/ADC-Timer_Config.png}
			\caption[Auszug aus dem Datenblatt zu den relevanten Bits des Registers \texttt{ADCSRA}]{Auszug aus dem Datenblatt zu den relevanten Bits des Registers \texttt{ADCSRA} (Seite 316 \cite{MicrochipTechnologyInc.ATmega32U4.Datasheet.2016}).}
			\label{fig:adc timer konfig}
		\end{figure}
		Die möglichen Werte der Prescaler des ADC-Timers sind in \cref{fig:adc timer konfig} gezeigt.
		Mit der gelb hinterlegten Konfiguration errechnet sich die maximale ADC-Frequenz unter Beibehalt einer Auflösung von 10Bit zu
		\begin{equation}
			f_{ADC} = \frac{\SI{16}{\mega\hertz}}{128} = \SI{125}{\kilo\hertz}
			\label{eq:adc timer}
		\end{equation}
		was sich zu einer Periodendauer für einen Taktzyklus von \SI{8}{\micro\second} übersetzt.
		Weiter geht aus dem Datenblatt hervor, dass die Samplingdauer des ADC 1,5 Zyklen und die Konvertierungsdauer 13 Zyklen des ADC-Timers benötigt.
		Mit dem gewählten Prescaler ergibt sich so die benötigte Mindestdauer für eine Messung von
		\begin{align}
			t_{messung} &= t_{Sample} + t_{Hold} = \frac{n_{Sample}}{f_{ADC}} + \frac{n_{Hold}}{f_{ADC}} \nonumber \\
						&= \SI{14}{\micro\second} + \SI{102}{\micro\second} = \SI{116}{\micro\second}
			\label{eq:adc messdauer}
		\end{align}

		Dem Datenblatt des verwendeten Touchscreens ist zu entnehmen, dass mit einer maximalen Eingangsimpedanz zum ADC von \SI{850}{\ohm} (x-Richtung) zu rechnen ist \cite{FUJITSU.touchscreen.datasheet}.
		\Cref{fig:analog input circuitry} zeigt die interne Eingangsverschaltung der ADC der verwendeten MCU. Die Kapazität \(C_{S/H}\) gilt es in der Zeit \(t_{Sample}\) auf einen Wert \(\frac{U_0}{2} \pm \frac{1}{2}LSB\) zu laden.

		\begin{gather}
			\frac{U_0}{2} - \frac{1}{2}LSB = U_0 \left( 1 - e^{-\frac{t_{Sample}}{RC}} \right) \nonumber \\
			\Leftrightarrow \nonumber \\
			t_{Sample} = -ln\left( \frac{1LSB}{2U_0} + \frac{1}{2}\right) \cdot RC
			\label{eq:samplingzeit}
		\end{gather}

		Mit Werten für \(R\), \(C_{S/H}\), \(U_0\) von \SI{850}{\ohm}, \SI{14}{\pico\farad} und \SI{5}{\volt} und \(\frac{1}{2}LSB = \frac{U_0}{2 \cdot 2^{10}}\) ergibt sich eine benötigte Samplingdauer von
		\begin{align}
			t_{Sample}	&= -ln\left( \frac{1}{2\cdot 2^{10}} + \frac{1}{2}\right) \cdot RC \nonumber \\
						&= -ln\left( \frac{1}{2\cdot 2^{10}} + \frac{1}{2}\right) \cdot \SI{850}{\ohm} \cdot \SI{14}{\pico\farad} \nonumber \\
						&= \SI{8,23}{\nano\second}
			\label{eq:samplingzeit gerechnet}
		\end{align}
		was sehr gut im Rahmen der gewählten ADC-Timerfrequenz liegt.
		Ebenso deckt es sich gut mit der Angabe des Datenblattes, bei Eingangsimpedanzen unterhalb von \SI{10}{\kilo\ohm} seien Samplingzeiten vernachlässigbar.
		\begin{figure}[h]
			\centering
			\includegraphics[width=.8\textwidth]{fig/adc-input-circuit.png}
			\caption[Interne Eingangsverschaltung der ADC]{Interne Eingangsverschaltung der ADC wie im Datenblatt gezeigt. Die Kapazität \(C_{S/H}\) ist hier der \textit{Sample and Hold}-Kondensator.}
			\label{fig:analog input circuitry}
		\end{figure}

		Zuletzt wird der externe Interrupt \texttt{INT0} an Pin PD0 im Register \texttt{EIMSK} durch setzen des Bits \texttt{INT0} aktiviert und im Register \texttt{EICRA} so konfiguriert, dass er auf steigende, wie fallende Flanken reagiert.
		Die Firmware soll in der Lage sein durch einen externen Schalter -- in \cref{fig:aufbau} Position 4 -- zwischen der Ausgabe von Koordinatenpaaren über die serielle Schnittstelle und der Steuerung der Maus des angeschlossenen PCs umschalten zu können. Zusätzlich wird die auf dem \textsc{Arduino}-Board befindliche LED als visueller Indikator des aktuellen Betriebsmodus genutzt.
		Das An- und Abschalten der LED erfolgt in der entsprechenden Interrupt-Serviceroutine.\par

		Zuletzt werden mit den befehlen
		\begin{lstlisting}[language=C++]
			Serial.begin(115200);
			Mouse.begin();
		\end{lstlisting}
		die oben erwähnte serielle Schnittstelle, sowie die Emulation der Maus initialisiert.

	\section{Hauptschleife und Unterfunktionen}
		Im Programmablauf werden in drei verschiedenen Situationen Konversionen der ADC benötigt.
		Während es sich hier durchaus um verschiedene physische ADC handeln kann, ist der grundlegende Ablauf wie etwa das Auslesen des Wandlungsergebnisses aus den entsprechenden Registern stets gleich.
		Diese sich wiederholende Routine leistet die Funktion \texttt{getADC()} in den Zeilen 35 bis 45 der \texttt{helper\_functions.cpp}.
		In zwei Schritten wird hier durch Setzen der Bits \texttt{ADSC} und \texttt{ADEN} des Registers \texttt{ADCSRA} die ADC-Peripherie aktiviert und eine Konvertierung am zuvor verbundenen ADC-Eingang gestartet.
		Die folgende Schleife überprüft periodisch den Zustand des Bits \texttt{ADSC}, welches nach Beendigung einer Konvertierung vom System automatisch auf 0 zurückgesetzt wird.\par
		Das Wandlungsergebnis befindet sich in den 8 Bit des Registers \texttt{ADCL} und den beiden niederwertigsten Bits des Registers \texttt{ADCH}.
		Da jede weitere Operation, die eines der beiden Register schreibend manipulieren würde -- wie etwa eine nachfolgende Konvertierung durch einen beliebigen anderen ADC -- den Inhalt der Register und damit das Wandlungsergebnis unbrauchbar machen würde, wird unmittelbar nach Verlassen der Schleife lesend auf die beiden Register zugegriffen.
		Sobald lesend auf das niederwertige Register \texttt{ADCL} zugegriffen wird, wird der Inhalt des höherwertigen Registers gegen Schreibzugriffe geschützt, bis auch auf jenes lesend zugegriffen wurde.
		Umgesetzt wird dies durch Erstellen einer 16Bit breiten lokalen Variable \texttt{val}, in deren ersten 8 Bit der Inhalt von \texttt{ADCL} geschrieben wird.
		Anschließend wird \texttt{val}, um 8 Bit verschoben, mit dem Inhalt von \texttt{ADCH} oder-verknüpft manipuliert.
		

		Um eine Messung zu verhindern während der Touchscreen gerade nicht berührt wird, werden innerhalb der Funktion \texttt{isFingered()} die Pins PF4-PF7 wie in \cref{fig:fingered} konfiguriert.
		\begin{figure}[h]
			\centering
			\includesvg[width=.8\textwidth]{fig/sch_fingering.svg}
			\caption{Schaltbild der Pinzustände zur Überprüfung einer validen Berührung.}
			\label{fig:fingered}
		\end{figure}